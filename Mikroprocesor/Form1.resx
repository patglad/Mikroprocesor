<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="timer1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <data name="textBox1.Text" xml:space="preserve">
    <value>INT 05:	Print screen is pressed
INT 16:	Keyboard services, AH=10h Read Character Extended 
	Input: 	AH=10h
	Return: 	AL = ASCII code, AH = scancode
INT 17:	Printer services, AH=00h Print Character to Printer
	Input:	AH=00h, AL=ASCII code of character to be printed,
                          	DX (DH+DL) = printer number (i.e. 0 = LPT1, 1 = LPT2, 2 = LPT3)
	Return: 	printer status: 
		AH7 = 1 printer idle, AH6 = 1 acknowledge, 
		AH5 = 1 printer out of paper, AH4 = 1 printer selected
		AH3 = 1 Input/Output error, AH2 = 2 not used,
		AH1 = 1 not used, AH0 = 0 printer timed-out
INT 19:	System reboot
INT 1A: 	Real Time Clock Services, AH = 03h Set RTC Time
	Input: 	AH=03h, CH=hour (BCD), CL=minutes (BCD), DH=seconds (BCD),
		DL=daylight savings flag (00h standard time, 01h daylight time)
	Return: 	nothing
INT 11:	Return System Information
	Retiurn:	AX	Equipment information:
			Bit Definition
			0 Not used
			1 Math coprocessor installed
			2 PS/2 mouse installed
			3 Not used
			4,5 Initial video mode:
				00 = EGA/VGA
				01 = 40x25 CGA
				10 = 80x25 CGA
				11 = Monochrome
			6,7 Diskette drives:
				00 = 1 drive
				01 = 2 drives
				10 = 3 drives
				11 = 4 drives
			8 Not used
			9-11 Number of serial adapters
			12 Game Adapter installed
			13 Not used
			14,15 Number of parallel adapters</value>
  </data>
  <data name="textBox5.Text" xml:space="preserve">
    <value>INT 10:    Video Services, AH=00h Set video mode
                Input:     AL Mode Value (0-7):
                               0 = 40x25 Black &amp; White
                               1 = 40x25 Color
                               2 = 80x25 Black &amp; White
                               3 = 80x25 Color
                               4 = 320x200 Color
                               5 = 320x200 Black &amp; White
                               6 = 640x200 Black &amp; White
                               7 = Monochrome only
	Return:	AH=00h
INT 13:	Fixed Disk Services, AH=01h Read disk status
	Input:	DL=drive number (80h-81h)
	Return:	AH	01h=Bad command
			02h=Bad address mark
			04h = Record not found
			05h = Controller reset error
			07h = Drive initialization error
			0Ah = Bad sector
			10h = ECC data error
			20h = Controller failed
			40h = Seek error
			AAh = Drive not ready
			BBh = Invalid controller error
			CCh = Controller write fault
			E0h = Unrecognized controller error
INT 14:    Serial Services, AH=01h Send character
	Input: 	AL=character to transmit
		DX=serial port (0-3)
	Return: 	AH=line status
INT 15:	System services, AH=86h Wait
	Input:	CX=number of microseconds to wait (high byte)
		DX=number of microseconds to wait (low byte)</value>
  </data>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>54</value>
  </metadata>
</root>